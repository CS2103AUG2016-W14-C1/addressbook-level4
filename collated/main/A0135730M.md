# A0135730M
###### /java/seedu/manager/commons/core/Messages.java
``` java
package seedu.manager.commons.core;

/**
 * Container for user visible messages.
 */
public class Messages {

    public static final String MESSAGE_UNKNOWN_COMMAND = "Unknown command";
    public static final String MESSAGE_INVALID_COMMAND_FORMAT = "Invalid command format! \n%1$s";
    public static final String MESSAGE_INVALID_ACTIVITY_DISPLAYED_INDEX = "The activity index provided is invalid";
    public static final String MESSAGE_ACTIVITIES_LISTED_OVERVIEW = "%1$d activities listed!";
    public static final String MESSAGE_CANNOT_PARSE_TO_DATE = "'%1$s' cannot be parsed to a date.";
    public static final String MESSAGE_EVENT_DATE_CONSTRAINTS = "Event has already ended before it starts.";
    public static final String MESSAGE_RECUR_NOT_POSITIVE = "Recurring number of times must be at least 1.";
    
}
```
###### /java/seedu/manager/commons/util/StringUtil.java
``` java
    /**
     * Attempts to validate an AMDate type
     * @param dateTime input string to be validated
     * 
     * @throws IllegalValueException if cannot parse to date
     */
    public static void validateAMDate(String dateTime) throws IllegalValueException {
        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(dateTime);
        if (groups.size() <= 0) {
            throw new IllegalValueException(String.format(MESSAGE_CANNOT_PARSE_TO_DATE, dateTime));
        }
    }
    
    /**
     * Attempts to validate two AMDate objects
     * @param dateTime input string to be validated
     * @param endDateTime input string to be validated
     * 
     * @throws IllegalValueException if cannot parse to date, or end earlier than start
     */
    public static void validateAMDate(String dateTime, String endDateTime) throws IllegalValueException {
        Parser parser = new Parser();
        
        // check that both inputs can be parsed to Date
        List<DateGroup> groups = parser.parse(dateTime);
        if (groups.size() <= 0) {
            throw new IllegalValueException(String.format(MESSAGE_CANNOT_PARSE_TO_DATE, dateTime));
        }
        List<DateGroup> endGroups = parser.parse(endDateTime);
        if (endGroups.size() <= 0) {
            throw new IllegalValueException(String.format(MESSAGE_CANNOT_PARSE_TO_DATE, endDateTime));
        }
        
        // check that end cannot be earlier than start
        final long endTime = endGroups.get(0).getDates().get(0).getTime();
        final long startTime = groups.get(0).getDates().get(0).getTime(); 
        if (endTime < startTime) {
            throw new IllegalValueException(MESSAGE_EVENT_DATE_CONSTRAINTS);
        }
    }
    
    /**
     * Returns true if s can be parsed as an AMDate type
     * @param s Should be trimmed
     */
    public static boolean isAMDate(String dateTime) {
        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(dateTime);
        return groups.size() > 0;
    }
}
```
###### /java/seedu/manager/logic/commands/AddCommand.java
``` java
    /**
     * Constructor for floating tasks
     */
    public AddCommand(String name) {
        this.toAdd = new Activity(name);
    }
    
    /**
     * Constructor for deadlines
     */
    public AddCommand(String name, String dateTime) {
        this.toAdd = new Activity(name, dateTime);
    }
    
    /**
     * Constructor for recurring deadlines
     */
    public AddCommand(String name, String dateTime, int recurNum, String recurUnit) {
        this.toAddList = new ActivityList();
        for (int numLater=0; numLater<recurNum; numLater++) {
            this.toAddList.add(new Activity(name, dateTime, numLater, recurUnit));
        }
    }

    /**
     * Constructor for events
     */
    public AddCommand(String name, String startDateTime, String endDateTime) {
        this.toAdd = new Activity(name, startDateTime, endDateTime);
    }
    
    /**
     * Constructor for recurring events
     */
    public AddCommand(String name, String startDateTime, String endDateTime, int recurNum, String recurUnit) {
        this.toAddList = new ActivityList();
        for (int numLater=0; numLater<recurNum; numLater++) {
            this.toAddList.add(new Activity(name, startDateTime, endDateTime, numLater, recurUnit));
        }
    }
    
```
###### /java/seedu/manager/logic/commands/SearchCommand.java
``` java
public class SearchCommand extends Command {

    public static final String COMMAND_WORD = "search";

    public static final String USAGE = "search KEYWORDS\n" + "search DATE_TIME\n" + "search STATUS";

    public static final String EXAMPLES = "search buy\n" + "search 21 Oct\n" + "search completed";   
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Searches all activities whose names contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " alice bob charlie";

    private final Set<String> keywords;
    private AMDate dateTime;
    private AMDate endDateTime;
    private String status;

    public SearchCommand(Set<String> keywords) {
        this.keywords = keywords;
        this.dateTime = null;
        this.endDateTime = null;
        this.status = null;
    }
    
    /**
     * Add the start/end dateTime range for search, use default end (end of the same day)
     * 
     * @param searchDateTime specified by user
     */
    public void addDateTimeRange(String searchDateTime) {
        addDateTimeRange(searchDateTime, searchDateTime);
    }
    
    /**
     * Add the start/end dateTime range for search
     * 
     * @param searchDateTime, searchEndDateTime specified by user
     */
    public void addDateTimeRange(String searchDateTime, String searchEndDateTime) {
        this.dateTime = new AMDate(searchDateTime);
        this.endDateTime = new AMDate(searchEndDateTime);
        this.dateTime.toStartOfDay();
        this.endDateTime.toEndOfDay();
    }
    
    /**
     * Add the status for search
     * 
     * @param status specified by user
     */
    public void addStatus(String status) {
    	this.status = status.toLowerCase();
    }
    
    @Override
    public CommandResult execute() {
        model.updateFilteredActivityList(keywords);
        if (this.dateTime != null && this.endDateTime != null) {
            model.updateFilteredActivityList(dateTime, endDateTime);
        }
        
        if (this.status != null) {
        	boolean isCompleted;
        	if ((this.status).equals("pending")) {
        		isCompleted = false;
        	} else {
        		isCompleted = true;
        	}    
        	model.updateFilteredActivityList(isCompleted);
        }
        	
        return new CommandResult(getMessageForActivityListShownSummary(model.getFilteredActivityList().size()));
    }

}
```
###### /java/seedu/manager/logic/parser/AMParser.java
``` java
    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    private static final Pattern ACTIVITY_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>\\S+)(?<arguments>.*)");
    
    private static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace
    
    private static final Pattern EVENT_RECURRING_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+) ((\"?)(from)\\3) (?<date>.+) ((\"?)(to)\\7) (?<endDate>.+) ((\"?)for\\11) (?<num>\\d+) (?<unit>(day|week|month|year))(s?)$",
                    Pattern.CASE_INSENSITIVE);
    
    private static final Pattern ADD_EVENT_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+) ((\"?)(from)\\3) (?<date>.+) ((\"?)(to)\\7) (?<endDate>.+)$",
                    Pattern.CASE_INSENSITIVE);
    
    private static final Pattern UPDATE_EVENT_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+ )?((\"?)(from)\\3) (?<date>.+) ((\"?)(to)\\7) (?<endDate>.+)$",
                    Pattern.CASE_INSENSITIVE);

    private static final Pattern DEADLINE_RECURRING_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+) ((\"?)(on|by)\\3) (?<date>.+) ((\"?)for\\7) (?<num>\\d+) (?<unit>(day|week|month|year))(s?)$",
                    Pattern.CASE_INSENSITIVE);
    
    private static final Pattern ADD_DEADLINE_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+) ((\"?)(on|by)\\3) (?<date>.+)$", 
                    Pattern.CASE_INSENSITIVE);
    
    private static final Pattern UPDATE_DEADLINE_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+ )?((\"?)(on|by)\\3) (?<date>.+)$", 
                    Pattern.CASE_INSENSITIVE);
    
    private static final Pattern FLOATING_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("^(?<name>[^/]+)$"); // variable number of tags

    /**
     * Various token counts
     */
    private static final int SEARCH_RANGE_TOKEN_COUNT = 2;
    
    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord").toLowerCase();
        final String arguments = matcher.group("arguments");
        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);
            
        case UpdateCommand.COMMAND_WORD:
            return prepareUpdate(arguments);
            
        case UndoCommand.COMMAND_WORD:
            return prepareUndo(arguments);
            
        case RedoCommand.COMMAND_WORD:
        	return prepareRedo(arguments);
            
        case MarkCommand.COMMAND_WORD:
            return prepareMark(arguments);
            
        case UnmarkCommand.COMMAND_WORD:
            return prepareUnmark(arguments);

        case StoreCommand.COMMAND_WORD:
            return prepareStore(arguments);
        	
        case SearchCommand.COMMAND_WORD:
            return prepareSearch(arguments);
            
        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case ListCommand.COMMAND_WORD:
            return new ListCommand();

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }

    /**
     * Parses arguments in the context of the add activity command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args){
        // compare with different activity types format and return AddCommand accordingly
        final Matcher eventRecurringMatcher = EVENT_RECURRING_ARGS_FORMAT.matcher(args.trim());
        final Matcher eventMatcher = ADD_EVENT_ARGS_FORMAT.matcher(args.trim());
        final Matcher deadlineRecurringMatcher = DEADLINE_RECURRING_ARGS_FORMAT.matcher(args.trim());
        final Matcher deadlineMatcher = ADD_DEADLINE_ARGS_FORMAT.matcher(args.trim());
        final Matcher floatingMatcher = FLOATING_ARGS_FORMAT.matcher(args.trim());
        
        try {
            if (eventRecurringMatcher.matches()) {
                final String eventName = eventRecurringMatcher.group("name").trim();
                final String eventDate = eventRecurringMatcher.group("date").trim();
                final String eventEndDate = eventRecurringMatcher.group("endDate").trim();
                final int eventRecurNumber = Integer.parseInt(eventRecurringMatcher.group("num").trim());
                final String eventRecurUnit = eventRecurringMatcher.group("unit").trim();
                
                StringUtil.validateAMDate(eventDate, eventEndDate);
                validateRecurNumber(eventRecurNumber);
                
                return new AddCommand(eventName, eventDate, eventEndDate, eventRecurNumber, eventRecurUnit);
            } else if (eventMatcher.matches()) {
                final String eventName = eventMatcher.group("name").trim();
                final String eventDate = eventMatcher.group("date").trim();
                final String eventEndDate = eventMatcher.group("endDate").trim();
                
                StringUtil.validateAMDate(eventDate, eventEndDate);
                
                return new AddCommand(eventName, eventDate, eventEndDate);
            } else if (deadlineRecurringMatcher.matches()) {
                final String deadlineName = deadlineRecurringMatcher.group("name").trim();
                final String deadlineDate = deadlineRecurringMatcher.group("date").trim();
                final int deadlineRecurNumber = Integer.parseInt(deadlineRecurringMatcher.group("num").trim());
                final String deadlineRecurUnit = deadlineRecurringMatcher.group("unit").trim();
                
                StringUtil.validateAMDate(deadlineDate);
                validateRecurNumber(deadlineRecurNumber);
                
                return new AddCommand(deadlineName, deadlineDate, deadlineRecurNumber, deadlineRecurUnit);
            } else if (deadlineMatcher.matches()) {
                final String deadlineName = deadlineMatcher.group("name").trim();
                final String deadlineDate = deadlineMatcher.group("date").trim();
                
                StringUtil.validateAMDate(deadlineDate);
                
                return new AddCommand(deadlineName, deadlineDate);
            } else if (floatingMatcher.matches()) {
                final String floatingName = floatingMatcher.group("name").trim();
                
                return new AddCommand(floatingName);
            } else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    private void validateRecurNumber(int num) throws IllegalValueException {
        if (num <= 0) {
            throw new IllegalValueException(MESSAGE_RECUR_NOT_POSITIVE);
        }
    }

```
###### /java/seedu/manager/logic/parser/AMParser.java
``` java
    /**
     * Parses arguments in the context of the update activity command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUpdate(String args) {
        final Matcher matcher = ACTIVITY_INDEX_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }
        
        // Validate index format
        Optional<Integer> index = parseIndex(matcher.group("targetIndex"));
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }
        final Integer targetIndex = index.get();
        
        // compare with different activity types format and return UpdateCommand accordingly
        String arguments = matcher.group("arguments").trim();
        final Matcher eventMatcher = UPDATE_EVENT_ARGS_FORMAT.matcher(arguments.trim());
        final Matcher deadlineMatcher = UPDATE_DEADLINE_ARGS_FORMAT.matcher(arguments.trim());
        final Matcher floatingMatcher = FLOATING_ARGS_FORMAT.matcher(arguments.trim());
        
        try {
            if (eventMatcher.matches()) {
                final String eventName = (eventMatcher.group("name") == null) ? null : eventMatcher.group("name").trim();
                final String eventDate = eventMatcher.group("date").trim();
                final String eventEndDate = eventMatcher.group("endDate").trim();
                
                StringUtil.validateAMDate(eventDate, eventEndDate);
                
                return new UpdateCommand(targetIndex, eventName, eventDate, eventEndDate);
            } else if (deadlineMatcher.matches()) {
                final String deadlineName = (deadlineMatcher.group("name") == null) ? null : deadlineMatcher.group("name").trim();
                final String deadlineDate = deadlineMatcher.group("date").trim();
                
                StringUtil.validateAMDate(deadlineDate);
                
                return new UpdateCommand(targetIndex, deadlineName, deadlineDate);
            } else if (floatingMatcher.matches()) {
                final String floatingName = floatingMatcher.group("name").trim();
                
                return new UpdateCommand(targetIndex, floatingName);
            } else {
                throw new IllegalValueException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

```
###### /java/seedu/manager/logic/parser/AMParser.java
``` java
    /**
     * Parses arguments in the context of the search command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSearch(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SearchCommand.MESSAGE_USAGE));
        }
        
        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        SearchCommand searchCommand = new SearchCommand(keywordSet);
        
        // add dateTime range if dateTime is indicated in part of search
        if (StringUtil.isAMDate(args.trim())) {
            String[] searchTimeTokens = args.trim().split(" to ");
            if (searchTimeTokens.length == SEARCH_RANGE_TOKEN_COUNT) {
                searchCommand.addDateTimeRange(searchTimeTokens[0].trim(), searchTimeTokens[1].trim());
            } else {
                searchCommand.addDateTimeRange(searchTimeTokens[0].trim());
            }
        }
        
        if ("pending".equals(args.trim().toLowerCase()) || "completed".equals(args.trim().toLowerCase())) {
        	searchCommand.addStatus(args.trim().toLowerCase());
        }
        
        return searchCommand;
    }
    
```
###### /java/seedu/manager/model/activity/Activity.java
``` java
	
	// Floating activity constructor
    
	public Activity(String name) {
	    this.type = ActivityType.FLOATING;
	    this.name = name;
		this.status = new Status();
		this.dateTime = null;
		this.endDateTime = null;
		this.selected = false;
	}
	
	// Deadline activity constructors
	
	/**
     * Constructor which gets dateTime in natural English from user input
     */
    public Activity(String name, String newDateTime) {
        this(name);
        this.type = ActivityType.DEADLINE;
        this.dateTime = new AMDate(newDateTime);
    }
	
	/**
     * Constructor which gets dateTime in epoch format from XML file
     */
    public Activity(String name, Long newEpochDateTime) {
        this(name);
        this.type = ActivityType.DEADLINE;
        this.dateTime = new AMDate(newEpochDateTime);
    }
    
    /**
     * Constructor which gets dateTime, offset and unit for recurrence
     */
    public Activity(String name, String newDateTime, int offset, String unit) {
        this(name);
        this.type = ActivityType.DEADLINE;
        this.dateTime = new AMDate(newDateTime);
        this.dateTime.addOffset(offset, unit);
    }
    
    // Event activity constructors
    
    /**
     * Constructor which gets start and end dateTime in natural English from user input
     */
    public Activity(String name, String newStartDateTime, String newEndDateTime) {
        this(name);
        this.type = ActivityType.EVENT;
        this.dateTime = new AMDate(newStartDateTime);
        this.endDateTime = new AMDate(newEndDateTime);
    }
    
    /**
     * Constructor which gets start and end dateTime in epoch format from XML file
     */
    public Activity(String name, Long newEpochStartDateTime, Long newEpochEndDateTime) {
        this(name);
        this.type = ActivityType.EVENT;
        this.dateTime = new AMDate(newEpochStartDateTime);
        this.endDateTime = new AMDate(newEpochEndDateTime);
    }
    
    /**
     * Constructor which gets start, end dateTime, offset and unit for recurrence
     */
    public Activity(String name, String newStartDateTime, String newEndDateTime, int offset, String unit) {
        this(name);
        this.type = ActivityType.EVENT;
        this.dateTime = new AMDate(newStartDateTime);
        this.dateTime.addOffset(offset, unit);
        this.endDateTime = new AMDate(newEndDateTime);
        this.endDateTime.addOffset(offset, unit);
    }
    
```
###### /java/seedu/manager/model/activity/Activity.java
``` java
    @Override
    public ActivityType getType() {
        return type;
    }
    
    public void setType(ActivityType type) {
        this.type = type;
    }
    
	@Override
```
###### /java/seedu/manager/model/activity/Activity.java
``` java
    public void setDateTime(String newDateTime) {
        assert newDateTime != null;
        assert !this.type.equals(ActivityType.FLOATING);
        if (this.dateTime == null) {
            this.dateTime = new AMDate(newDateTime);
        } else {
            this.dateTime.setAMDate(newDateTime);
        }
    }
    
    public void setEndDateTime(String newEndDateTime) {
        assert !this.type.equals(ActivityType.FLOATING);
        // remove endDateTime if activity is converted to deadline
        if (this.type.equals(ActivityType.DEADLINE)) {
            assert newEndDateTime == null;
            this.endDateTime = null;
        } else if (this.type.equals(ActivityType.EVENT)) {
            if (this.endDateTime == null) {
                this.endDateTime = new AMDate(newEndDateTime);
            } else {
                this.endDateTime.setAMDate(newEndDateTime);
            }
        }
    }
	
	@Override
	public boolean equals(Object o) {
	    return o == this
	                // basic Activity equality
	            || (o instanceof Activity
	                && this.name.equals(((Activity)o).name)
	                && this.status.equals(((Activity)o).status)
	                && this.type.equals(((Activity)o).type)
	                   // floating equality
	                && (this.type.equals(ActivityType.FLOATING)
	                   // deadline equality
	                   || (this.type.equals(ActivityType.DEADLINE)
	                      && this.dateTime.equals(((Activity)o).dateTime))
	                   // event equality
	                   || (this.type.equals(ActivityType.EVENT)
	                      && this.dateTime.equals(((Activity)o).dateTime)
	                      && this.endDateTime.equals(((Activity)o).endDateTime)))
	                );
	}
	
    @Override
```
###### /java/seedu/manager/model/activity/ActivityList.java
``` java
    /**
     * Updates the equivalent activity in the list.
     */
    public void update(Activity toUpdate, String newName, String newDateTime, String newEndDateTime) {
    	assert toUpdate != null;
    	assert internalList.contains(toUpdate);
    	
    	int toUpdateIndex = internalList.indexOf(toUpdate);
    	Activity toUpdateInList = internalList.get(toUpdateIndex);
    	// Update Activity name (if there is new name)
    	if (newName != null && !newName.equals("")) {
    	    toUpdateInList.setName(newName);
    	}
    	// Update task to event
    	if (newDateTime != null && newEndDateTime != null) {
    	    toUpdateInList.setType(ActivityType.EVENT);
    	    toUpdateInList.setDateTime(newDateTime);
    	    toUpdateInList.setEndDateTime(newEndDateTime);
    	// Update task to deadline
	    } else if (newDateTime != null) {
	        toUpdateInList.setType(ActivityType.DEADLINE);
    		toUpdateInList.setDateTime(newDateTime);
    		toUpdateInList.setEndDateTime(null);
    	}
    	Collections.sort(internalList);
    }
    
```
###### /java/seedu/manager/model/activity/ActivityType.java
``` java
public enum ActivityType {
    FLOATING, DEADLINE, EVENT
}
```
###### /java/seedu/manager/model/activity/AMDate.java
``` java
    
    /** dateTime manipulation methods **/
    
    public void toStartOfDay() {
        this.dateTime.setHours(0);
        this.dateTime.setMinutes(0);
        this.dateTime.setSeconds(0);
    }
    
    public void toEndOfDay() {
        this.dateTime.setHours(23);
        this.dateTime.setMinutes(59);
        this.dateTime.setSeconds(59);
    }
    
    /**
     * Adds offset number of time unit to dateTime
     */
    public void addOffset(int offset, String unit) {
        TimeUnit timeUnit = TimeUnit.valueOf(unit.toUpperCase());
        switch (timeUnit) {
            case DAY:
                this.dateTime.setDate(this.dateTime.getDate() + offset);
                return;
            case WEEK:
                this.dateTime.setDate(this.dateTime.getDate() + (offset * 7));
                return;
            case MONTH:
                this.dateTime.setMonth(this.dateTime.getMonth() + offset);
                return;
            case YEAR:
                this.dateTime.setYear(this.dateTime.getYear() + offset);
                return;
            default:
                this.dateTime.setDate(this.dateTime.getDate());
                break;
        }
    }
    
```
###### /java/seedu/manager/model/ModelManager.java
``` java
    public void updateFilteredActivityList(AMDate dateTime, AMDate endDateTime){
        updateFilteredActivityList(new PredicateExpression(new DateQualifier(dateTime, endDateTime)));
    }
```
###### /java/seedu/manager/model/ModelManager.java
``` java
    private class DateQualifier implements Qualifier {
        private AMDate dateTime;
        private AMDate endDateTime;

        DateQualifier(AMDate dateTime, AMDate endDateTime) {
            this.dateTime = dateTime;
            this.endDateTime = endDateTime;
        }

        @Override
        public boolean run(Activity activity) {
            if (activity.getType().equals(ActivityType.FLOATING)) {
                // no need check dateTime for floating activity, but should not return either
                return false;
            } else if (activity.getType().equals(ActivityType.DEADLINE)) {
                // return true if deadline falls within dateTime range 
                Long deadlineTime = activity.getDateTime().getTime(); 
                return deadlineTime >= dateTime.getTime() && deadlineTime <= endDateTime.getTime(); 
            } else if (activity.getType().equals(ActivityType.EVENT)) {
                // return true if either start or end of event falls within dateTime range
                Long eventTime = activity.getDateTime().getTime();
                Long endEventTime = activity.getEndDateTime().getTime();
                return !(endEventTime < dateTime.getTime() || eventTime > endDateTime.getTime());
            } else {
                return false; // should not happen
            }
        }

    }
```
###### /java/seedu/manager/storage/XmlAdaptedActivity.java
``` java
    /**
     * Converts a given Activity into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedActivity
     */
    public XmlAdaptedActivity(Activity source) {
        type = source.getType();
        name = source.getName();
        isCompleted = source.getStatus().isCompleted();
        
        if (type.equals(ActivityType.DEADLINE)) {
            epochDateTime = source.getDateTime().getTime();
        } if (type.equals(ActivityType.EVENT)) {
            epochDateTime = source.getDateTime().getTime();
            epochEndDateTime = source.getEndDateTime().getTime();
        }
    }

    /**
     * Converts this jaxb-friendly adapted activity object into the model's Activity object.
     *
     * @return model's Activity object converted from jaxb
     */
    public Activity toModelType() {
        Activity newActivity;
        if (type.equals(ActivityType.EVENT)) {
            newActivity = new Activity(this.name, epochDateTime, epochEndDateTime);
        } else if(type.equals(ActivityType.DEADLINE)) {
            newActivity = new Activity(this.name, epochDateTime);    
        } else {
            newActivity = new Activity(this.name);
        }
    	newActivity.setStatus(this.isCompleted);
    	
        return newActivity;
    }
```
###### /java/seedu/manager/ui/ActivityCard.java
``` java
    private String generateDateTimeString(AMDate dateTime) {
        assert dateTime != null;
        
        return dateTime.getDayOfWeek() + DATE_DELIMITER +
               dateTime.getDay() + DATE_DELIMITER +
               dateTime.getMonth() + DATETIME_DELIMITER + 
               dateTime.getHour() + TIME_DELIMITER +
               dateTime.getMinutes();
    }
```
###### /java/seedu/manager/ui/StatusBarFooter.java
``` java
package seedu.manager.ui;

import com.google.common.eventbus.Subscribe;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;
import seedu.manager.commons.core.LogsCenter;
import seedu.manager.commons.events.model.ActivityManagerChangedEvent;
import seedu.manager.commons.events.ui.ChangeStorageFileDisplayEvent;
import seedu.manager.commons.util.FxViewUtil;

import org.controlsfx.control.StatusBar;

import java.util.Date;
import java.util.logging.Logger;

/**
 * A ui for the status bar that is displayed at the footer of the application.
 */
public class StatusBarFooter extends UiPart {
    private static final String INFO_CHANGE_STORAGE = "Changing data storage location to: %1$s";
    private static final String INFO_LAST_UPDATED = "Setting last updated status to %1$s";
    private static final String MESSAGE_NOT_UPDATED_YET = "Not updated yet in this session";
    private static final Logger logger = LogsCenter.getLogger(StatusBarFooter.class);
    private StatusBar syncStatus;
    private StatusBar saveLocationStatus;

    private GridPane mainPane;

    @FXML
    private AnchorPane saveLocStatusBarPane;

    @FXML
    private AnchorPane syncStatusBarPane;

    private AnchorPane placeHolder;

    private static final String FXML = "StatusBarFooter.fxml";

    public static StatusBarFooter load(Stage stage, AnchorPane placeHolder, String saveLocation) {
        StatusBarFooter statusBarFooter = UiPartLoader.loadUiPart(stage, placeHolder, new StatusBarFooter());
        statusBarFooter.configure(saveLocation);
        return statusBarFooter;
    }

    public void configure(String saveLocation) {
        addMainPane();
        addSyncStatus();
        setSyncStatus(MESSAGE_NOT_UPDATED_YET);
        addSaveLocation();
        setSaveLocation("./" + saveLocation);
        registerAsAnEventHandler(this);
    }

    private void addMainPane() {
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    private void setSaveLocation(String location) {
        this.saveLocationStatus.setText(location);
    }

    private void addSaveLocation() {
        this.saveLocationStatus = new StatusBar();
        FxViewUtil.applyAnchorBoundaryParameters(saveLocationStatus, 0.0, 0.0, 0.0, 0.0);
        saveLocStatusBarPane.getChildren().add(saveLocationStatus);
    }

    private void setSyncStatus(String status) {
        this.syncStatus.setText(status);
    }

    private void addSyncStatus() {
        this.syncStatus = new StatusBar();
        FxViewUtil.applyAnchorBoundaryParameters(syncStatus, 0.0, 0.0, 0.0, 0.0);
        syncStatusBarPane.getChildren().add(syncStatus);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (GridPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Subscribe
    public void handleActivityManagerChangedEvent(ActivityManagerChangedEvent abce) {
        String lastUpdated = (new Date()).toString();
        logger.info(LogsCenter.getEventHandlingLogMessage(abce, String.format(INFO_LAST_UPDATED, lastUpdated)));
        setSyncStatus("Last Updated: " + lastUpdated);
    }
    
    @Subscribe
    public void handleActivityManagerChangedStorageFile(ChangeStorageFileDisplayEvent event){
    	logger.info(LogsCenter.getEventHandlingLogMessage(event, String.format(INFO_CHANGE_STORAGE, event.file)));
    	setSaveLocation(event.file);
    }
}
```
