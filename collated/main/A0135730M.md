# A0135730M
###### /java/seedu/manager/commons/core/Messages.java
``` java
package seedu.manager.commons.core;

/**
 * Container for user visible messages.
 */
public class Messages {

    public static final String MESSAGE_UNKNOWN_COMMAND = "Unknown command";
    public static final String MESSAGE_INVALID_COMMAND_FORMAT = "Invalid command format! \n%1$s";
    public static final String MESSAGE_INVALID_ACTIVITY_DISPLAYED_INDEX = "The activity index provided is invalid";
    public static final String MESSAGE_ACTIVITIES_LISTED_OVERVIEW = "%1$d activities listed!";
    public static final String MESSAGE_CANNOT_PARSE_TO_DATE = "'%1$s' cannot be parsed to a date.";
    public static final String MESSAGE_EVENT_DATE_CONSTRAINTS = "Event has already ended before it starts.";
    public static final String MESSAGE_RECUR_NOT_POSITIVE = "Recurring number of times must be at least 1.";
    
}
```
###### /java/seedu/manager/commons/util/StringUtil.java
``` java
    /**
     * Attempts to validate an AMDate type
     * @param dateTime input string to be validated
     * 
     * @throws IllegalValueException if cannot parse to date
     */
    public static void validateAMDate(String dateTime) throws IllegalValueException {
        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(dateTime);
        if (groups.size() <= 0) {
            throw new IllegalValueException(String.format(MESSAGE_CANNOT_PARSE_TO_DATE, dateTime));
        }
    }
    
    /**
     * Attempts to validate two AMDate objects
     * @param dateTime input string to be validated
     * @param endDateTime input string to be validated
     * 
     * @throws IllegalValueException if cannot parse to date, or end earlier than start
     */
    public static void validateAMDate(String dateTime, String endDateTime) throws IllegalValueException {
        Parser parser = new Parser();
        
        // check that both inputs can be parsed to Date
        List<DateGroup> groups = parser.parse(dateTime);
        if (groups.size() <= 0) {
            throw new IllegalValueException(String.format(MESSAGE_CANNOT_PARSE_TO_DATE, dateTime));
        }
        List<DateGroup> endGroups = parser.parse(endDateTime);
        if (endGroups.size() <= 0) {
            throw new IllegalValueException(String.format(MESSAGE_CANNOT_PARSE_TO_DATE, endDateTime));
        }
        
        // check that end cannot be earlier than start
        final long endTime = endGroups.get(0).getDates().get(0).getTime();
        final long startTime = groups.get(0).getDates().get(0).getTime(); 
        if (endTime < startTime) {
            throw new IllegalValueException(MESSAGE_EVENT_DATE_CONSTRAINTS);
        }
    }

    /**
     * Returns true if s has quotation marks at the start and end, with string inside
     * @param s String to check
     */
    public static boolean hasQuotationMarks(String s) {
        return s.length() > 2
               && ((s.charAt(0) == '"' && s.charAt(s.length()-1) == '"')
                   || (s.charAt(0) == '\'' && s.charAt(s.length()-1) == '\''));
    }

    /**
     * Returns string with begin and end quotation marks trimmed
     * @param s String to trim, assumed to have quotation marks at the start and end
     */
    public static String trimQuotationMarks(String s) {
        return s.substring(1, s.length()-1);
    }

    /**
     * Returns true if s contains status
     * @param s String to check
     */
    public static boolean hasStatus(String s) {
        return "pending".equals(s.toLowerCase()) 
                || "completed".equals(s.toLowerCase());
    }

    /**
     * Returns either status based on s's content
     * @param s String which contains a status
     */
    public static String getStatus(String s) {
        if ("pending".equals(s.toLowerCase())) {
            return "pending";
        } else {
            return "completed";
        }
    }
    
    /**
     * Returns true if s can be parsed as an AMDate type
     * @param s Should be trimmed
     */
    public static boolean hasAMDates(String s) {
        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(s);
        return groups.size() > 0;
    }

    /**
     * Extracts the start and end date from s
     * @param s String which contains date(s)
     * @return list with a start and end date
     */
    public static List<Long> getDateRange(String s) {
        Parser parser = new Parser();
        DateGroup group = parser.parse(s).get(0);
        List<Date> dates = group.getDates();
        List<Long> ranges = new ArrayList<Long>();
        
        // get the first and last date and use it as the range
        // if there is only one date, first date == last date
        ranges.add(dates.get(0).getTime());
        ranges.add(dates.get(dates.size() - 1).getTime());
        // sort to ensure start always earlier than end
        Collections.sort(ranges);
        return ranges;
    }
}
```
###### /java/seedu/manager/logic/commands/AddCommand.java
``` java
    /**
     * Constructor for floating tasks
     */
    public AddCommand(String name) {
        this.toAdd = new Activity(name);
    }
    
    /**
     * Constructor for deadlines
     */
    public AddCommand(String name, String dateTime) {
        this.toAdd = new Activity(name, dateTime);
    }
    
    /**
     * Constructor for recurring deadlines
     */
    public AddCommand(String name, String dateTime, int recurNum, String recurUnit) {
        this.toAddList = new ActivityList();
        for (int numLater=0; numLater<recurNum; numLater++) {
            this.toAddList.add(new Activity(name, dateTime, numLater, recurUnit));
        }
    }

    /**
     * Constructor for events
     */
    public AddCommand(String name, String startDateTime, String endDateTime) {
        this.toAdd = new Activity(name, startDateTime, endDateTime);
    }
    
    /**
     * Constructor for recurring events
     */
    public AddCommand(String name, String startDateTime, String endDateTime, int recurNum, String recurUnit) {
        this.toAddList = new ActivityList();
        for (int numLater=0; numLater<recurNum; numLater++) {
            this.toAddList.add(new Activity(name, startDateTime, endDateTime, numLater, recurUnit));
        }
    }
    
```
###### /java/seedu/manager/logic/commands/SearchCommand.java
``` java
public class SearchCommand extends Command {

    private enum SearchType { KEYWORDS, STATUS, DATE };
    
    public static final String COMMAND_WORD = "search";

    public static final String USAGE = "search \"KEYWORDS\"\n" + "search DATE_TIME\n" + "search STATUS";

    public static final String EXAMPLES = "search \"buy\"\n" + "search 21 Oct\n" + "search completed";   
    
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Searches all activities whose names contain any of "
            + "the specified keywords (in quotes, case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " \"alice bob charlie\"";

    private SearchType type;
    private Set<String> keywords;
    private AMDate dateTime;
    private AMDate endDateTime;
    private String status;

    /**
     * Constructor to search by keywords
     */
    public SearchCommand(Set<String> keywords) {
        this.type = SearchType.KEYWORDS;
        this.keywords = keywords;
    }
    
    /**
     * Constructor to search by status
     * @param status either "completed" or "pending"
     */
    public SearchCommand(String status) {
        this.type = SearchType.STATUS;
        this.status = status;
    }
    
    /**
     * Constructor to search by date ranges
     * @param ranges contains exactly a start and end date
     */
    public SearchCommand(List<Long> ranges) {
        assert ranges.size() == 2;
        this.type = SearchType.DATE;
        this.dateTime = new AMDate(ranges.get(0));
        this.endDateTime = new AMDate(ranges.get(1));
        
        // expand range from start of dateTime to end of endDateTime
        this.dateTime.toStartOfDay();
        this.endDateTime.toEndOfDay();
    }
    
    @Override
    public CommandResult execute() {
        switch (this.type) {
        case KEYWORDS:
            assert keywords != null;
            model.updateFilteredActivityList(keywords);
            break;
        case STATUS:
            assert status != null;
            boolean isCompleted = "completed".equals(status);
            model.updateFilteredActivityList(isCompleted);
            break;
        case DATE:
            assert dateTime != null;
            assert endDateTime != null;
            model.updateFilteredActivityList(dateTime, endDateTime);
            break;
        }
        model.indicateActivityListPanelUpdate();	
        return new CommandResult(getMessageForActivityListShownSummary(model.getFilteredActivityList().size()));
    }

}
```
###### /java/seedu/manager/logic/parser/AMParser.java
``` java
    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    private static final Pattern ACTIVITY_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>\\S+)(?<arguments>.*)");
    
    private static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace
    
    private static final Pattern EVENT_RECURRING_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+) ((\"?)(from)\\3) (?<date>.+) ((\"?)(to)\\7) (?<endDate>.+) ((\"?)for\\11) (?<num>\\d+) (?<unit>(day|week|month|year))(s?)$",
                    Pattern.CASE_INSENSITIVE);
    
    private static final Pattern ADD_EVENT_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+) ((\"?)(from)\\3) (?<date>.+) ((\"?)(to)\\7) (?<endDate>.+)$",
                    Pattern.CASE_INSENSITIVE);
    
    private static final Pattern UPDATE_EVENT_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+ )?((\"?)(from)\\3) (?<date>.+) ((\"?)(to)\\7) (?<endDate>.+)$",
                    Pattern.CASE_INSENSITIVE);

    private static final Pattern DEADLINE_RECURRING_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+) ((\"?)(on|by)\\3) (?<date>.+) ((\"?)for\\7) (?<num>\\d+) (?<unit>(day|week|month|year))(s?)$",
                    Pattern.CASE_INSENSITIVE);
    
    private static final Pattern ADD_DEADLINE_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+) ((\"?)(on|by)\\3) (?<date>.+)$", 
                    Pattern.CASE_INSENSITIVE);
    
    private static final Pattern UPDATE_DEADLINE_ARGS_FORMAT =
            Pattern.compile("^(?<name>.+ )?((\"?)(on|by)\\3) (?<date>.+)$", 
                    Pattern.CASE_INSENSITIVE);
    
    private static final Pattern FLOATING_ARGS_FORMAT = // '/' forward slashes are reserved for delimiter prefixes
            Pattern.compile("^(?<name>[^/]+)$"); // variable number of tags
    
```
###### /java/seedu/manager/logic/parser/AMParser.java
``` java
    /**
     * Parses arguments in the context of the add activity command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args){
        // compare with different activity types format and return AddCommand accordingly
        final Matcher eventRecurringMatcher = EVENT_RECURRING_ARGS_FORMAT.matcher(args.trim());
        final Matcher eventMatcher = ADD_EVENT_ARGS_FORMAT.matcher(args.trim());
        final Matcher deadlineRecurringMatcher = DEADLINE_RECURRING_ARGS_FORMAT.matcher(args.trim());
        final Matcher deadlineMatcher = ADD_DEADLINE_ARGS_FORMAT.matcher(args.trim());
        final Matcher floatingMatcher = FLOATING_ARGS_FORMAT.matcher(args.trim());
        
        try {
            if (eventRecurringMatcher.matches()) {
                final String eventName = eventRecurringMatcher.group("name").trim();
                final String eventDate = eventRecurringMatcher.group("date").trim();
                final String eventEndDate = eventRecurringMatcher.group("endDate").trim();
                final int eventRecurNumber = Integer.parseInt(eventRecurringMatcher.group("num").trim());
                final String eventRecurUnit = eventRecurringMatcher.group("unit").trim();
                
                StringUtil.validateAMDate(eventDate, eventEndDate);
                validateRecurNumber(eventRecurNumber);
                
                return new AddCommand(eventName, eventDate, eventEndDate, eventRecurNumber, eventRecurUnit);
            } else if (eventMatcher.matches()) {
                final String eventName = eventMatcher.group("name").trim();
                final String eventDate = eventMatcher.group("date").trim();
                final String eventEndDate = eventMatcher.group("endDate").trim();
                
                StringUtil.validateAMDate(eventDate, eventEndDate);
                
                return new AddCommand(eventName, eventDate, eventEndDate);
            } else if (deadlineRecurringMatcher.matches()) {
                final String deadlineName = deadlineRecurringMatcher.group("name").trim();
                final String deadlineDate = deadlineRecurringMatcher.group("date").trim();
                final int deadlineRecurNumber = Integer.parseInt(deadlineRecurringMatcher.group("num").trim());
                final String deadlineRecurUnit = deadlineRecurringMatcher.group("unit").trim();
                
                StringUtil.validateAMDate(deadlineDate);
                validateRecurNumber(deadlineRecurNumber);
                
                return new AddCommand(deadlineName, deadlineDate, deadlineRecurNumber, deadlineRecurUnit);
            } else if (deadlineMatcher.matches()) {
                final String deadlineName = deadlineMatcher.group("name").trim();
                final String deadlineDate = deadlineMatcher.group("date").trim();
                
                StringUtil.validateAMDate(deadlineDate);
                
                return new AddCommand(deadlineName, deadlineDate);
            } else if (floatingMatcher.matches()) {
                final String floatingName = floatingMatcher.group("name").trim();
                
                return new AddCommand(floatingName);
            } else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    private void validateRecurNumber(int num) throws IllegalValueException {
        if (num <= 0) {
            throw new IllegalValueException(MESSAGE_RECUR_NOT_POSITIVE);
        }
    }

```
###### /java/seedu/manager/logic/parser/AMParser.java
``` java
    /**
     * Parses arguments in the context of the update activity command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUpdate(String args) {
        final Matcher matcher = ACTIVITY_INDEX_ARGS_FORMAT.matcher(args.trim());
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }
        
        // Validate index format
        Optional<Integer> index = parseIndex(matcher.group("targetIndex"));
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }
        final Integer targetIndex = index.get();
        
        // compare with different activity types format and return UpdateCommand accordingly
        String arguments = matcher.group("arguments").trim();
        final Matcher eventMatcher = UPDATE_EVENT_ARGS_FORMAT.matcher(arguments.trim());
        final Matcher deadlineMatcher = UPDATE_DEADLINE_ARGS_FORMAT.matcher(arguments.trim());
        final Matcher floatingMatcher = FLOATING_ARGS_FORMAT.matcher(arguments.trim());
        
        try {
            if (eventMatcher.matches()) {
                final String eventName = (eventMatcher.group("name") == null) ? null : eventMatcher.group("name").trim();
                final String eventDate = eventMatcher.group("date").trim();
                final String eventEndDate = eventMatcher.group("endDate").trim();
                
                StringUtil.validateAMDate(eventDate, eventEndDate);
                
                return new UpdateCommand(targetIndex, eventName, eventDate, eventEndDate);
            } else if (deadlineMatcher.matches()) {
                final String deadlineName = (deadlineMatcher.group("name") == null) ? null : deadlineMatcher.group("name").trim();
                final String deadlineDate = deadlineMatcher.group("date").trim();
                
                StringUtil.validateAMDate(deadlineDate);
                
                return new UpdateCommand(targetIndex, deadlineName, deadlineDate);
            } else if (floatingMatcher.matches()) {
                final String floatingName = floatingMatcher.group("name").trim();
                
                return new UpdateCommand(targetIndex, floatingName);
            } else {
                throw new IllegalValueException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

```
###### /java/seedu/manager/logic/parser/AMParser.java
``` java
    /**
     * Parses arguments in the context of the search command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSearch(String args) {
        args = args.trim();
        // search by keywords if args is wrapped with quotation marks
        if (StringUtil.hasQuotationMarks(args)) {
            return prepareSearchByKeywords(StringUtil.trimQuotationMarks(args));
        // search by status if args contains status
        } else if (StringUtil.hasStatus(args)) {
            return prepareSearchByStatus(StringUtil.getStatus(args));
        // search by dates if args contains dates    
        } else if (StringUtil.hasAMDates(args)) {
            return prepareSearchByDate(StringUtil.getDateRange(args));
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SearchCommand.MESSAGE_USAGE));
        }
    }
    
    /**
     * Parses arguments in the context of the search by keywords command.
     *
     * @param keywordsArg the keywords portion of args
     * @return the prepared command
     */
    private Command prepareSearchByKeywords(String keywordsArg) {
        // keywords delimited by whitespace
        final String[] keywords = keywordsArg.split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new SearchCommand(keywordSet);
    }
    
    /**
     * Parses arguments in the context of the search by status command.
     *
     * @param status either "pending" or "completed"
     * @return the prepared command
     */
    private Command prepareSearchByStatus(String status) {
        return new SearchCommand(status);
    }
    
    /**
     * Parses arguments in the context of the search by date command.
     *
     * @param range a list of dates in epoch time
     * @return the prepared command
     */
    private Command prepareSearchByDate(List<Long> range) {
        return new SearchCommand(range);
    }
    
```
###### /java/seedu/manager/model/activity/Activity.java
``` java
	
	// Floating activity constructor
    
	public Activity(String name) {
	    this.type = ActivityType.FLOATING;
	    this.name = name;
		this.status = new Status();
		this.dateTime = null;
		this.endDateTime = null;
		this.selected = false;
	}
	
	// Deadline activity constructors
	
	/**
     * Constructor which gets dateTime in natural English from user input
     */
    public Activity(String name, String newDateTime) {
        this(name);
        this.type = ActivityType.DEADLINE;
        this.dateTime = new AMDate(newDateTime);
    }
	
	/**
     * Constructor which gets dateTime in epoch format from XML file
     */
    public Activity(String name, Long newEpochDateTime) {
        this(name);
        this.type = ActivityType.DEADLINE;
        this.dateTime = new AMDate(newEpochDateTime);
    }
    
    /**
     * Constructor which gets dateTime, offset and unit for recurrence
     */
    public Activity(String name, String newDateTime, int offset, String unit) {
        this(name);
        this.type = ActivityType.DEADLINE;
        this.dateTime = new AMDate(newDateTime);
        this.dateTime.addOffset(offset, unit);
    }
    
    // Event activity constructors
    
    /**
     * Constructor which gets start and end dateTime in natural English from user input
     */
    public Activity(String name, String newStartDateTime, String newEndDateTime) {
        this(name);
        this.type = ActivityType.EVENT;
        this.dateTime = new AMDate(newStartDateTime);
        this.endDateTime = new AMDate(newEndDateTime);
    }
    
    /**
     * Constructor which gets start and end dateTime in epoch format from XML file
     */
    public Activity(String name, Long newEpochStartDateTime, Long newEpochEndDateTime) {
        this(name);
        this.type = ActivityType.EVENT;
        this.dateTime = new AMDate(newEpochStartDateTime);
        this.endDateTime = new AMDate(newEpochEndDateTime);
    }
    
    /**
     * Constructor which gets start, end dateTime, offset and unit for recurrence
     */
    public Activity(String name, String newStartDateTime, String newEndDateTime, int offset, String unit) {
        this(name);
        this.type = ActivityType.EVENT;
        this.dateTime = new AMDate(newStartDateTime);
        this.dateTime.addOffset(offset, unit);
        this.endDateTime = new AMDate(newEndDateTime);
        this.endDateTime.addOffset(offset, unit);
    }
    
```
###### /java/seedu/manager/model/activity/Activity.java
``` java
    @Override
    public ActivityType getType() {
        return type;
    }
    
    public void setType(ActivityType type) {
        this.type = type;
    }
    
	@Override
```
###### /java/seedu/manager/model/activity/Activity.java
``` java
    public void setDateTime(String newDateTime) {
        assert newDateTime != null;
        assert !this.type.equals(ActivityType.FLOATING);
        if (this.dateTime == null) {
            this.dateTime = new AMDate(newDateTime);
        } else {
            this.dateTime.setAMDate(newDateTime);
        }
    }
    
```
###### /java/seedu/manager/model/activity/Activity.java
``` java
	@Override
	public boolean equals(Object o) {
	    return o == this
	                // basic Activity equality
	            || (o instanceof Activity
	                && this.name.equals(((Activity)o).name)
	                && this.status.equals(((Activity)o).status)
	                && this.type.equals(((Activity)o).type)
	                   // floating equality
	                && (this.type.equals(ActivityType.FLOATING)
	                   // deadline equality
	                   || (this.type.equals(ActivityType.DEADLINE)
	                      && this.dateTime.equals(((Activity)o).dateTime))
	                   // event equality
	                   || (this.type.equals(ActivityType.EVENT)
	                      && this.dateTime.equals(((Activity)o).dateTime)
	                      && this.endDateTime.equals(((Activity)o).endDateTime)))
	                );
	}
	
    @Override
```
###### /java/seedu/manager/model/activity/ActivityList.java
``` java
    /**
     * Updates the equivalent activity in the list.
     */
    public void update(Activity toUpdate, String newName, String newDateTime, String newEndDateTime) {
    	assert toUpdate != null;
    	assert internalList.contains(toUpdate);
    	
    	int toUpdateIndex = internalList.indexOf(toUpdate);
    	Activity toUpdateInList = internalList.get(toUpdateIndex);
    	
    	Activity newActivity;
    	switch (toUpdateInList.getType()) {
    	case DEADLINE:
    	    newActivity = new Activity(toUpdateInList.getName(), toUpdateInList.getDateTime().getTime());
    	    break;
    	case EVENT:
    	    newActivity = new Activity(toUpdateInList.getName(), toUpdateInList.getDateTime().getTime(), toUpdateInList.getEndDateTime().getTime());
    	    break;
    	case FLOATING:
    	default:
            newActivity = new Activity(toUpdateInList.getName());
            break;
    	}
        
        // Update Activity name (if there is new name)
    	if (newName != null && !"".equals(newName)) {
    	    newActivity.setName(newName);
    	}
    	// Update task to event
    	if (newDateTime != null && newEndDateTime != null) {
    	    newActivity.setType(ActivityType.EVENT);
    	    newActivity.setDateTime(newDateTime);
    	    newActivity.setEndDateTime(newEndDateTime);
    	// Update task to deadline
	    } else if (newDateTime != null) {
	        newActivity.setType(ActivityType.DEADLINE);
    		newActivity.setDateTime(newDateTime);
    		newActivity.removeEndDateTime();
    	}
    	internalList.set(toUpdateIndex, newActivity);
    	Collections.sort(internalList);
    }
    
```
###### /java/seedu/manager/model/activity/ActivityType.java
``` java
public enum ActivityType {
    FLOATING, DEADLINE, EVENT
}
```
###### /java/seedu/manager/model/activity/AMDate.java
``` java
    
    /** dateTime manipulation methods **/
    
    public void toStartOfDay() {
        this.dateTime.setHours(0);
        this.dateTime.setMinutes(0);
        this.dateTime.setSeconds(0);
    }
    
    public void toEndOfDay() {
        this.dateTime.setHours(23);
        this.dateTime.setMinutes(59);
        this.dateTime.setSeconds(59);
    }
    
    /**
     * Adds offset number of time unit to dateTime
     */
    public void addOffset(int offset, String unit) {
        TimeUnit timeUnit = TimeUnit.valueOf(unit.toUpperCase());
        switch (timeUnit) {
            case DAY:
                this.dateTime.setDate(this.dateTime.getDate() + offset);
                return;
            case WEEK:
                this.dateTime.setDate(this.dateTime.getDate() + (offset * 7));
                return;
            case MONTH:
                this.dateTime.setMonth(this.dateTime.getMonth() + offset);
                return;
            case YEAR:
                this.dateTime.setYear(this.dateTime.getYear() + offset);
                return;
            default:
                this.dateTime.setDate(this.dateTime.getDate());
                break;
        }
    }
    
```
###### /java/seedu/manager/model/ModelManager.java
``` java
    public void updateFilteredActivityList(AMDate dateTime, AMDate endDateTime){
        updateFilteredActivityList(new PredicateExpression(new DateQualifier(dateTime, endDateTime)));
    }
    

    private void updateFilteredActivityList(Expression expression) {
        filteredActivities.setPredicate(expression::satisfies);
    }
    
    private void updateFilteredActivityList(Predicate<Activity> predicate) {
        filteredActivities.setPredicate(predicate);
    }
    
```
###### /java/seedu/manager/model/ModelManager.java
``` java
    private class DateQualifier implements Qualifier {
        private AMDate dateTime;
        private AMDate endDateTime;

        DateQualifier(AMDate dateTime, AMDate endDateTime) {
            this.dateTime = dateTime;
            this.endDateTime = endDateTime;
        }

        @Override
        public boolean run(Activity activity) {
            if (activity.getType().equals(ActivityType.FLOATING)) {
                // no need check dateTime for floating activity, but should not return either
                return false;
            } else if (activity.getType().equals(ActivityType.DEADLINE)) {
                // return true if deadline falls within dateTime range 
                Long deadlineTime = activity.getDateTime().getTime(); 
                return deadlineTime >= dateTime.getTime() && deadlineTime <= endDateTime.getTime(); 
            } else if (activity.getType().equals(ActivityType.EVENT)) {
                // return true if either start or end of event falls within dateTime range
                Long eventTime = activity.getDateTime().getTime();
                Long endEventTime = activity.getEndDateTime().getTime();
                return !(endEventTime < dateTime.getTime() || eventTime > endDateTime.getTime());
            } else {
                return false; // should not happen
            }
        }

    }

}
```
###### /java/seedu/manager/storage/XmlAdaptedActivity.java
``` java
/**
 * JAXB-friendly version of an Activity.
 */
public class XmlAdaptedActivity {

    @XmlElement(required = true)
    private ActivityType type;
    
    @XmlElement(required = true)
    private String name;

    @XmlElement(required = false)
    private Long epochDateTime;
    
    @XmlElement(required = false)
    private Long epochEndDateTime;
    
    @XmlElement(required = true)
    private boolean isCompleted;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedActivity() {}

    /**
     * Converts a given Activity into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedActivity
     */
    public XmlAdaptedActivity(Activity source) {
        type = source.getType();
        name = source.getName();
        isCompleted = source.getStatus().isCompleted();
        
        if (type.equals(ActivityType.DEADLINE)) {
            epochDateTime = source.getDateTime().getTime();
        } if (type.equals(ActivityType.EVENT)) {
            epochDateTime = source.getDateTime().getTime();
            epochEndDateTime = source.getEndDateTime().getTime();
        }
    }

    /**
     * Converts this jaxb-friendly adapted activity object into the model's Activity object.
     *
     * @return model's Activity object converted from jaxb
     */
    public Activity toModelType() {
        Activity newActivity;
        if (type.equals(ActivityType.EVENT)) {
            newActivity = new Activity(this.name, epochDateTime, epochEndDateTime);
        } else if(type.equals(ActivityType.DEADLINE)) {
            newActivity = new Activity(this.name, epochDateTime);    
        } else {
            newActivity = new Activity(this.name);
        }
    	newActivity.setStatus(this.isCompleted);
    	
        return newActivity;
    }
}
```
###### /java/seedu/manager/ui/ActivityCard.java
``` java
    private String generateDateTimeString(AMDate dateTime) {
        assert dateTime != null;
        
        return dateTime.getDayOfWeek() + DATE_DELIMITER +
               dateTime.getDay() + DATE_DELIMITER +
               dateTime.getMonth() + DATETIME_DELIMITER + 
               dateTime.getHour() + TIME_DELIMITER +
               dateTime.getMinutes();
    }

    public HBox getLayout() {
        return cardPane;
    }
    
```
